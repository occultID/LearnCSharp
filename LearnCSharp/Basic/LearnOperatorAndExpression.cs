/*【110：学习运算符与表达式】
 * 运算符概览：参考C#语言定义规范
	• 运算符，也称为操作符
	• 运算符是用来操作数据的，被运算符操作的数据称为操作数(Operand)
		○ 操作数可以是文本(字面量)、字段、局部变量和表达式
	• C#内置的运算符如下所示，类别从上至下优先级依次降低，同一行中的运算符运算优先级是一样的
		条例					类别					运算符
		主要表达式			主					x.y、f(x)、a[i]、x?.y、x?[i]、x++、x--、x!、new、typeof、checked、unchecked、default、delegate、nameof、sizeof、stackalloc、x->y
		一元运算符			一元					+x、-x、!x、~x、++x、--x、^x、(T)x、await、&x、*x、true、false
		范围运算符			二元|范围				x..y
		switch和with表达式	switch和with表达式	switch、with
		算术运算符			二元|乘法				*、/、%
		算术运算符			二元|加减				+、-
		移位运算符			二元|移位				<<、>>、>>>
		关系类型检测运算符		二元|关系和类型检测		<、>、<=、>=、is、as
		关系类型检测运算符		二元|相等				==、!=
		逻辑运算符			二元|逻辑与			&
		逻辑运算符			二元|逻辑XOR			^
		逻辑运算符			二元|逻辑或			|
		条件逻辑运算符			二元|条件与			&&
		条件逻辑运算符			二元|条件或			||
		Null合并运算符		二元|null合并			??
		条件运算符			三元|条件				?:
		赋值运算符，			赋值和lambda表达式		=、*=、/=、%=、+=、-=、<<=、>>=、>>>=、&=、^=、|=、??=、=>
		匿名函数表达式

 * 运算符的本质
	• 运算符的本质是函数（即算法）的“简记法”
		○ 举例解释：假如没有发明“+”运算符，只有Add函数，算式3+4+5将只能写成Add（Add（3,4）,5），当算式相加很复杂时，函数的表示也将更为复杂
	• 运算符不能脱离与它关联的数据类型
		○ 可以说运算符就是与固定数据类型相关联的一套基本算法的简记法
		○ 可以自定义数据类型重载运算符
	
 * 运算符的优先级与运算顺序
	• 运算符的优先级
		○ 可以使用圆括号提高被括起来的表达式的优先级
		○ 圆括号可以嵌套
		○ 嵌套的圆括号最里层的圆括号优先级最高
	• 同优先级运算符的运算顺序
		○ 除了带有赋值功能的运算符，同优先级运算符都是由左向右进行运算
		○ 带有赋值功能的运算符的运算顺序是由右向左
		○ 与数学运算不同，计算机语言的同优先级运算没有“结合律”
			§ 3+4+5在计算机语言中只能理解为Add(Add(3,4),5)，不能理解为Add(3,Add(4,5))

 * 运算符重载
	• 所有的运算符在C#中都有对应的预定义实现，其中所有的一元运算符和二元运算符都具有在任何表达式中自动可用的预定义实现
	• 除了预定义的运算符实现外，在有需求时可以在自定义类型或结构中含声明来引入用户自定义的运算符实现，这称为运算符重载
		○ 严格来说，这不算是自定义运算符，用户只能在自定义类型或结构中重新定义已有的运算符来实现对关联类型的操作
		○ 运算符重载时，必须指定至少一个操作数的类型为重载运算符所在的类型
		○ 只有以下运算符支持有用户自定义重载实现
			§ 可重载的一元运算符：+、-、！、~、++、--、true、false
			§ 可重载的二元运算符：+、-、*、/、%、&、|、^、<<、>>、==、!=、>、<、>=、<=
			§ 注意：重载二元运算符（+、-、*、/、%、&、|、^、<<、>>）时会自动重载其对应的复合赋值运算符（+=、-=、*=、/=、%=、&=、|=、^=、<<=、>>=）
			§ 注意：重载二元运算符（==、>、>=）同时必须重载二元运算符（!=、<、<=）
			§ 注意：true、false运算符的重载实际是使重载它的类型支持用于表示true或false，重载该运算符的返回值只能是bool值且必须两者同时实现
			§ 注意：对于隐式转换和显示转换，分别使用implicit和explicit关键字来定义重载
	• 重载运算符的优先级
		○ 用户定义的重载运算符的优先级始终优先于预定义的运算操作符
			§ 只有当不存在适用的用户定义运算符实现时，编译器才会考虑预定义的运算符重载
	• 重载运算符的方式
		○ 一元运算符--在包含类中声明并实现如下方法
			§ public static 返回数据类型 operator 运算符(操作数数据类型 形参名)
			   { 
					实现代码返回对应类型值
			   }
			§ 注意：当运算符为true或false时，返回数据类型必须为bool，但无论如何，返回数据类型不能为void
			§ 注意：运算符操作数即参数的数据类型必须为其包含类型
		○ 二元运算符--在包含类中声明并实现如下方法
			§ public static 返回数据类型 operator 运算符(左操作数数据类型 形参名, 右操作数数据类型 形参名)
			   {
					实现代码返回对应类型值
			   }
			§ 注意：当运算符为==、!=、>、<、>=、<=时，返回数据类型必须为bool，但无论如何，返回数据类型不能为void
			§ 注意：运算符的左右操作数即参数的数据类型，至少有一个必须是包含类型
		○ 隐式类型转换--在包含类中声明并实现如下方法
			§ public static implicit operator 返回数据类型(操作数数据类型 形参名)
			   {
					实现代码返回对应类型值
			   }
			§ 注意：返回数据类型和操作数数据类型中至少有一个必须为包含类型
		○ 显示类型转换--在包含类中声明并实现如下方法
			§ public static explicit operator 返回数据类型(操作数数据类型 形参名)
			   {
					实现代码返回对应类型值
			   }
			§ 注意：返回数据类型和操作数数据类型中至少有一个必须为包含类型

 * 表达式的定义
	• 表达式是运算符和操作数构成的序列
		○ 这个序列的功能是：求值
			§ 值可能是：一个值、对象实例、方法、命名空间
	• C#语言对表达式的定义
		○ 算法逻辑的最基本（最小）单元，通过求值来表达一定的算法意图
		○ 因为运算符有优先级，所以表达式也有了优先级

 * 表达式分类
	• 对于直接求值的表达式可以分类为如下：
		○ 值
			§ 任何能得到值的运算，都是表达式
			§ 每个值都有关联的数据类型，该类型也是这个表达式的数据类型
		○ 变量
			§ 每个变量都有关联的类型，即变量的声明类型
		○ null文本
			§ 具有此分类的表达式可隐式转换为引用类型或可以为null的类型
		○ 匿名函数
			§ 具有此分类的表达式可隐式转换为兼容的委托类型或表达式目录树类型
		○ 属性访问
			§ 每个属性访问都有关联的类型，即属性的类型
			§ 属性访问可能具有关联的实例表达式
			§ 当调用实例属性访问的get\set访问器时，对关联实例表达式的求值结果将成为该属性的值
		○ 索引器访问
			§ 每个索引器访问都有关联的类型，即索引器的元素类型
			§ 索引器访问具有关联的实例表达式和关联的参数列表
				□ 如果调用索引器访问的get/set访问器
					® 则关联实例表达式的计算结果将成为该索引器的值
					® 参数列表的计算结果将成为调用的参数列表
		○ Nothing 
			§ 对返回值为void的方法的调用会发生这种情况
			§ 归类为Nothing的表达式仅在语句表达式的上下文中有效
	• 对于作为较大表达式的子表达式出现的表达式分类为如下
		○ 命名空间
			§ 具有此分类的表达式只能作为成员访问运算符的左侧出现
			§ 在任何其他上下文中，归类为命名空间的表达式会导致编译时错误
		○ 类型
			§ 具有此分类的表达式只能作为成员访问的左侧，或者作为as运算符、is运算符或typeof运算符的操作数
			§ 在其他任何上下文中，归类为类型的表达式会导致编译时错误
		○ 方法组
			§ 由成员查找产生的一组重载方法
				□ 成员查找是确定名称在类型上下文中的含义的过程
			§ 方法组可以具有关联的实例表达式和关联的类型参数列表
				□ 当调用实例方法时，对实例表达式的求值结果将成为该方法组所示的实例
			§ 方法组可以在调用表达式或委托创建表达式中使用，并且可以隐式转换为兼容的委托类型
			§ 在其他任何上下文中，归类为方法组的表达式会导致编译错误
		○ 事件访问
			§ 每个事件访问都有关联的类型，即事件的类型
			§ 事件访问可能具有关联的实例表达式
			§ 事件访问可能显示为+=和-=运算符的左操作数
			§ 在其他任何上下文中，归类为事件访问的表达式会导致编译时错误
		○ 抛出表达式
			§ 用于在一个表达式的多个上下文中抛出异常
			§ 可以通过隐式转换将抛出表达式转换为任何类型

 * 表达式的值
	• 求值注意优先级
	• 表达式的最终结果绝不会是命名空间、类型、方法组或事件访问
		○ 对于分类为命名空间、类型、方法或事件访问的表达式是仅在某些上下文中允许的中间构造
	• 通过执行get/set访问器的调用，始终可以将属性访问或索引访问表达式重新分类为值表达式
		○ 特定访问器由属性或索引器访问的上下文确定
			§ 如果属性或索引器访问是赋值的目标，则调用set访问器来为其分配新值，并将新值作为属性或索引器访问的值
			§ 属性或索引器访问的值是通过get访问器来获取的，如果不存在get访问器，则会发生编译时错误
	• 变量的值只是当前存储在变量标识的存储位置中的值
		○ 在获取变量的值之前，必须保证变量已被明确赋值

 * 静态和动态绑定
	• 绑定：根据构成表达式的类型或值(参数、操作数、接收方)，确定操作含义的过程通常称为“绑定”
		○ 静态绑定--符合以下条件的绑定
			§ 根据构成表达式的类型或值，表达式的操作含义在编译时已明确确定
			§ 如果表达式包含错误，编译器将检测并报告错误
		○ 动态绑定--符合以下条件的绑定
			§ 根据构成表达式的类型或值，表达式的操作含义在运行时才确定
			§ 表达式的类型是动态类型(dynamic)，所有的绑定都是基于运行时中对象的实际类型而非编译时指定的类型
			§ 采取动态绑定操作时，编译器不会执行任何检查
			§ 如果运行时绑定失败，则会在运行时抛出异常
	• C#中的以下操作服从绑定
		○ 成员访问
		○ 方法调用
		○ 委托调用
		○ 元素访问
		○ 对象创建
		○ 重载的一元运算符
		○ 重载的二元运算符
		○ 赋值运算符
		○ 隐式和显示转换
	• 绑定时间
		○ 静态绑定在编译时进行
		○ 动态绑定在运行时进行
 */

using Microsoft.VisualBasic;
using System;
using System.Data;
using System.Reflection.Metadata.Ecma335;
using System.Runtime.InteropServices;

namespace LearnCSharp.Basic
{
    internal class LearnOperatorAndExpression
    {
        /*【11001：算术运算符】
         * ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			运算符		使用形式		名称				类别		功能作用							附加说明													可重载性

			++			x++			后缀增量运算符		主要		► 按 1 递增其操作数				► 后缀：当存在赋/取值操作时，先赋/取值，后递增					可重载
						++x			前缀增量运算符		一元										► 前缀：当存在赋/取值操作时，先递增，后赋/取值

			--			x--			后缀减量运算符		主要		► 按 1 递减其操作数				► 后缀：当存在赋/取值操作时，先赋/取值，后递减					可重载
						--x			前缀减量运算符		一元										► 前缀：当存在赋/取值操作时，先递减，后赋/取值

			+			+x			加运算符			一元		► 返回其操作数的值																			可重载

			-			-x			减运算符			一元		► 其操作数的数值取负																		可重载

			*			x*y			乘法运算符		二元		► 计算其操作数的乘积																		可重载
						
			/			x/y			除法运算符		二元		► 它的左侧操作数除以右侧操作数		► 右侧操作数不能为0										可重载
																							► 整型整数除法无法整除时结果只保留整数部分，且不会四舍五入

			%			x%y			取余运算符		二元		► 左侧操作数除以右侧操作数后的余数	► 右侧操作数不能为0										可重载

			+			x+y			加法运算符		二元		► 计算其操作数的和																			可重载

			-			x-y			减法运算符		二元		► 从其左侧操作数中减去其右侧操作数															可重载
		* ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		*/
		public static void LearnArithmeticOperator()
		{
            Console.WriteLine("\n------示例：算术运算符------\n");

			int x = Random.Shared.Next(100, 1000);
			int y = Random.Shared.Next(100, 1000);

			int result = 0;
			int resultX = 0;
			int resultY = 0;

            Console.WriteLine($"当前提供两个整数------ x：{x} | y：{y}");
            Console.WriteLine();

            //后缀增量运算符示例
            resultX = x++;
			resultY = y++;
			Console.WriteLine($"后缀增量运算符，先取值------ x++：{resultX} | y++：{resultY}");
            Console.WriteLine($"后缀增量运算符，后递增------   x：{x} |   y：{y}");
            Console.WriteLine();

            //前缀增量运算符示例
            resultX = ++x;
			resultY = ++y;
            Console.WriteLine($"前缀增量运算符，先递增------   x：{x} |   y：{y}");
            Console.WriteLine($"前缀增量运算符，后取值------ ++x：{resultX} | ++y：{resultY}");
            Console.WriteLine();

            //后缀减量运算符示例
            resultX = x--;
			resultY = y--;
            Console.WriteLine($"后缀减量运算符，先取值------ x--：{resultX} | y--：{resultY}");
            Console.WriteLine($"后缀减量运算符，后递减------   x：{x} |   y：{y}");
            Console.WriteLine();

            //前缀减量运算符示例
            resultX = --x;
			resultY = --y;
            Console.WriteLine($"前缀减量运算符，先递减------   x：{x} |   y：{y}");
            Console.WriteLine($"前缀减量运算符，后取值------ --x：{resultX} | --y：{resultY}");
            Console.WriteLine();

            //加减运算符示例
            resultX = +x;
			resultY = +y;
            Console.WriteLine($"加运算符，返回操作数值------ +x：{resultX,-4} | +y：{resultY,-4}");

			resultX = -x;
			resultY = -y;
            Console.WriteLine($"减运算符，操作数值取负------ -x：{resultX,-4} | -y：{resultY,-4}");
            Console.WriteLine();

            //乘法、除法和取余运算符示例，整数类型的两个操作数的商也存储为整数类型的话会直接丢弃小数部分
            result = x * y;
			Console.WriteLine($"乘法运算符，取乘积------ x * y ：{result}");

			result = x / y;
            Console.WriteLine($"除法运算符，取  商------ x / y ：{result}");

			result = x % y;
            Console.WriteLine($"取余运算符，取余数------ x % y ：{result}");
            Console.WriteLine();

            //加法、减法运算符示例
            result = x + y;
            Console.WriteLine($"加法运算符，取  和------ x + y ：{result}");

			result = x - y;
            Console.WriteLine($"减法运算符，取  差------ x - y ：{result}");

            Console.WriteLine();
        }

        /*【11002：布尔逻辑运算符】
		 * ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			运算符	使用形式		名称				类别		功能作用																附加说明										可重载性

			!		!x			逻辑非运算符		一元		► 计算操作数的逻辑非，也就是取bool操作数当前值的相反值																	可重载

			&		x&y			逻辑与运算符		二元		► 计算操作数的逻辑与，仅当两个bool操作数均为true时结果为true，否则为false		► 始终计算两个操作数的bool值						可重载

			|		x|y			逻辑或运算符		二元		► 计算操作数的逻辑或，仅当两个bool操作数均为false时结果为false，否则为true		► 始终计算两个操作数的bool值						可重载

			^		x^y			逻辑异或运算符		二元		► 计算操作数的逻辑异或，仅当两个bool操作数值相反时结果为true，否则为false		► 始终计算两个操作数的bool值						可重载

			&&		x&&y		条件逻辑与运算符	二元		► 计算操作数的逻辑与，仅当两个bool操作数均为true时结果为true，否则为false		► 当左操作数的bool值为false时，不再计算右操作数	不可重载，但如果用户定义类型以某种方式重载 true 和 false 运算符以及 & 运算符，可以对相应类型的操作数执行 && 运算

			||		x||y		条件逻辑或运算符	二元		► 计算操作数的逻辑或，仅当两个bool操作数均为false时结果为false，否则为true		► 当左操作数的bool值为true时，不再计算右操作数		不可重载，但如果用户定义类型以某种方式重载 true 和 false 运算符以及 | 运算符，可以对相应类型的操作数执行 || 运算
		* ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		*/
		public static void LearnBooleanLogicalOperator()
		{
            Console.WriteLine("\n------示例：布尔逻辑运算符------\n");

			bool t = true;
			bool f = false;

            Console.WriteLine($"当前提供两个布尔类型变量------ t：{t} | f：{f}");

            //逻辑非运算符示例
            Console.WriteLine();
            Console.WriteLine($"逻辑非运算符，取操作数相反值------ !t：{!t} | !f：{!f}");

            //逻辑与运算符示例
            Console.WriteLine();
            Console.WriteLine($"逻辑与运算符，取操作数逻辑与------ t & f ：{t & f}");

            //逻辑或运算符示例
            Console.WriteLine();
            Console.WriteLine($"逻辑或运算符，取操作数逻辑或------ t | f ：{t | f}");

            //逻辑异或运算符示例
            Console.WriteLine();
            Console.WriteLine($"逻辑异或运算符，取操作数逻辑异或------ t ^ f ：{t ^ f}");

			//声明一个局部方法用于测试条件逻辑运算符的计算逻辑
			bool TestRightOperand()
			{
                Console.WriteLine("右操作数被计算");
				return default;
			}

            //条件逻辑与运算符，当左操作数的bool值为false时，不再计算右操作数
            Console.WriteLine();
			Console.WriteLine($"条件逻辑与运算符------ f && TestRightOperand() ：{f && TestRightOperand()}");

            //条件逻辑或运算符，当左操作数的bool值为true时，不再计算右操作数
            Console.WriteLine();
            Console.WriteLine($"条件逻辑与运算符------ t || TestRightOperand() ：{t || TestRightOperand()}");

            Console.WriteLine();
        }

        /*【11003：位运算符和移位运算符】
		 * ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			运算符	使用形式		名称				类别		功能作用												附加说明																												可重载性

			~		~x			按位求补运算符		一元		► 通过反转操作数的每个二进制位产生其按位求补结果																																	可重载

			&		x&y			位逻辑与运算符		二元		► 计算其整型操作数的位逻辑 AND																																				可重载

			|		x|y			位逻辑或运算符		二元		► 计算其整型操作数的位逻辑 OR																																				可重载

			^		x^y			位逻辑异或运算符	二元		► 计算其整型操作数的位逻辑异或																																				可重载

			<<		x<<y		左移位运算符		二元		► 将其左侧操作数的二进制位向左移动右侧操作数定义的位数		► 如果左侧操作数sbyte、byte、short、ushort 或 char类型，则其值将转换为 int 类型												可重载
																											► 左移运算会放弃超出结果类型范围的高阶位，并将低阶空位位置设置为零
																											► 实际移位计数取决于左操作数的类型
																												• int/uint：移位计数由右操作数的二进制位低阶五位定义，即 y&0b_11111
																												• long/ulong：移位计数由右操作数的二进制位低阶六位定义，即 y&0b_111111

			>>		x>>y		右移位运算符		二元		► 将其左侧操作数的二进制位向右移动右侧操作数定义的位数		► 如果左侧操作数sbyte、byte、short、ushort 或 char类型，则其值将转换为 int 类型												可重载
																											► 右移位运算会放弃低阶位
																											► 如果左侧操作数的类型是 int 或 long，则右移运算符将执行算术移位：左侧操作数的最高有效位（符号位）的值将传播到高顺序空位位置
																											► 如果左侧操作数的类型是 uint 或 ulong，则右移运算符执行逻辑移位：高顺序空位位置始终设置为零
																											► 实际移位计数取决于左操作数的类型
																											     • int/uint：移位计数由右操作数的二进制位低阶五位定义，即 y&0b_11111
																											     • long/ulong：移位计数由右操作数的二进制位低阶六位定义，即 y&0b_111111

			>>>		x>>>y		无符号右移位运算符	二元		► 将其左侧操作数的二进制位向右移动右侧操作数定义的位数		► 如果左侧操作数sbyte、byte、short、ushort 或 char类型，则其值将转换为 int 类型												可重载
																											► 无论左侧操作数是何类型，始终执行逻辑移位，即高顺序空位位置始终设置为零
																											► 实际移位计数取决于左操作数的类型
																												 • int/uint：移位计数由右操作数的二进制位低阶五位定义，即 y&0b_11111
																												 • long/ulong：移位计数由右操作数的二进制位低阶六位定义，即 y&0b_111111
		* ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		*/
        public static void LearnBitwiseAndShiftOperator()
		{
            Console.WriteLine("\n------示例：位和移位运算符------\n");

			int x = -100;
			int y = 100;

			int shiftCount1 = 16;
			int shiftCount2 = 32;
			int shiftCount3 = 48;

			int result = 0;
            int resultX = 0;
            int resultY = 0;

            Console.WriteLine($"当前提供两个整数，并显示其二进制值\nx：十进制------ {x,-5} | 二进制------ {x:b32}\ny：十进制------ {y,-5} | 二进制------ {y:b32}");
            Console.WriteLine();

            //按位求补运算符示例
            resultX = ~x;
			resultY = ~y;
            Console.WriteLine($"按位求补运算符示例\n~x：十进制------ {resultX,-5} | 二进制------ {resultX:b32}\n~y：十进制------ {resultY,-5} | 二进制------ {resultY:b32}");
            Console.WriteLine();

            //位逻辑与运算符示例
            result = x & y;
            Console.WriteLine($"位逻辑与运算符示例\nx & y ：十进制------ {result}\n二进制------ {result:b32}");
			Console.WriteLine();

            //位逻辑或运算符示例
            result = x | y;
            Console.WriteLine($"位逻辑或运算符示例\nx | y ：十进制------ {result}\n二进制------ {result:b32}");
			Console.WriteLine();

            //位逻辑异或运算符示例
            result = x ^ y;
            Console.WriteLine($"位逻辑异或运算符示例\nx ^ y ：十进制------ {result}\n二进制------ {result:b32}");
			Console.WriteLine();

            //左移位运算符示例
            resultX = x << shiftCount1;
            resultY = y << shiftCount1;
            Console.WriteLine($"左移位运算符示例\n给定移位计数：{shiftCount1} | 实际移位计数：{shiftCount1 & 0b_11111}\n" +
                $"x << {shiftCount1} ：十进制结果------ {resultX,-12} | 二进制结果------ {resultX:b32}\n" +
                $"y << {shiftCount1} ：十进制结果------ {resultY,-12} | 二进制结果------ {resultY:b32}");
            Console.WriteLine();

            resultX = x << shiftCount2;
            resultY = y << shiftCount2;
            Console.WriteLine($"给定移位计数：{shiftCount2} | 实际移位计数：{shiftCount2 & 0b_11111}\n" +
                $"x << {shiftCount2} ：十进制结果------ {resultX,-12} | 二进制结果------ {resultX:b32}\n" +
                $"y << {shiftCount2} ：十进制结果------ {resultY,-12} | 二进制结果------ {resultY:b32}");
			Console.WriteLine();

            resultX = x << shiftCount3;
            resultY = y << shiftCount3;
            Console.WriteLine($"给定移位计数：{shiftCount3} | 实际移位计数：{shiftCount3 & 0b_11111}\n" +
                $"x << {shiftCount3} ：十进制结果------ {resultX,-12} | 二进制结果------ {resultX:b32}\n" +
                $"y << {shiftCount3} ：十进制结果------ {resultY,-12} | 二进制结果------ {resultY:b32}");
            Console.WriteLine();

            //右移位运算符示例
            resultX = x >> shiftCount1;
            resultY = y >> shiftCount1;
            Console.WriteLine($"右移位运算符示例\n给定移位计数：{shiftCount1} | 实际移位计数：{shiftCount1 & 0b_11111}\n" +
                $"x >> {shiftCount1} ：十进制结果------ {resultX,-12} | 二进制结果------ {resultX:b32}\n" +
                $"y >> {shiftCount1} ：十进制结果------ {resultY,-12} | 二进制结果------ {resultY:b32}");
			Console.WriteLine();

            resultX = x >> shiftCount2;
            resultY = y >> shiftCount2;
            Console.WriteLine($"给定移位计数：{shiftCount2} | 实际移位计数：{shiftCount2 & 0b_11111}\n" +
                $"x >> {shiftCount2} ：十进制结果------ {resultX,-12} | 二进制结果------ {resultX:b32}\n" +
                $"y >> {shiftCount2} ：十进制结果------ {resultY,-12} | 二进制结果------ {resultY:b32}");
			Console.WriteLine();

            resultX = x >> shiftCount3;
            resultY = y >> shiftCount3;
            Console.WriteLine($"给定移位计数：{shiftCount3} | 实际移位计数：{shiftCount3 & 0b_11111}\n" +
                $"x >> {shiftCount3} ：十进制结果------ {resultX,-12} | 二进制结果------ {resultX:b32}\n" +
                $"y >> {shiftCount3} ：十进制结果------ {resultY,-12} | 二进制结果------ {resultY:b32}");
			Console.WriteLine();

            //无符号右移位运算符示例
            resultX = x >>> shiftCount1;
            resultY = y >>> shiftCount1;
            Console.WriteLine($"无符号右移位运算符示例\n给定移位计数：{shiftCount1} | 实际移位计数：{shiftCount1 & 0b_11111}\n" +
                $"x >>> {shiftCount1} ：十进制结果------ {resultX,-12} | 二进制结果------ {resultX:b32}\n" +
                $"y >>> {shiftCount1} ：十进制结果------ {resultY,-12} | 二进制结果------ {resultY:b32}");
			Console.WriteLine();

            resultX = x >>> shiftCount2;
            resultY = y >>> shiftCount2;
            Console.WriteLine($"给定移位计数：{shiftCount2} | 实际移位计数：{shiftCount2 & 0b_11111}\n" +
                $"x >>> {shiftCount2} ：十进制结果------ {resultX,-12} | 二进制结果------ {resultX:b32}\n" +
                $"y >>> {shiftCount2} ：十进制结果------ {resultY,-12} | 二进制结果------ {resultY:b32}");
			Console.WriteLine();

            resultX = x >>> shiftCount3;
            resultY = y >>> shiftCount3;
            Console.WriteLine($"给定移位计数：{shiftCount3} | 实际移位计数：{shiftCount3 & 0b_11111}\n" +
                $"x >>> {shiftCount3} ：十进制结果------ {resultX,-12} | 二进制结果------ {resultX:b32}\n" +
                $"y >>> {shiftCount3} ：十进制结果------ {resultY,-12} | 二进制结果------ {resultY:b32}");
			Console.WriteLine();
        }

        /*【11004：相等与比较运算符】
		 * ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			运算符	使用形式		名称				类别		功能作用																	附加说明															可重载性

			==		x==y		相等运算符		二元		► 检查其操作数是否相等，如果操作数相等，相等运算符返回 true，否则返回 false			► 当内容相等时，值类型相等。 当两个变量引用同一存储时，引用类型相等			可重载，但必须同时重载 != 运算符

			!=		x!=y		不等运算符		二元		► 检查其操作数是否不等，如果操作数不相等，不等运算符返回 true，否则返回 false		► 当内容相等时，值类型相等。 当两个变量引用同一存储时，引用类型相等			可重载，但必须同时重载 == 运算符

			>		x>y			大于运算符		二元		► 如果左侧操作数大于右侧操作数，> 运算符返回 true，否则返回 false																					可重载，但必须同时重载 < 运算符

			>=		x>=y		大于或等于运算符	二元		► 如果左侧操作数大于或等于右侧操作数，>= 运算符返回 true，否则返回 false																			可重载，但必须同时重载 <= 运算符

			<		x<y			小于运算符		二元		► 如果左侧操作数小于右侧操作数，< 运算符返回 true，否则返回 false																					可重载，但必须同时重载 > 运算符

			<=		x<=y		小于或等于运算符	二元		► 如果左侧操作数小于或等于右侧操作数，<= 运算符返回 true，否则返回 false																			可重载，但必须同时重载 >= 运算符
		* ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		*/
		public static void LearnEqualityAndComparisonOperator()
		{
            Console.WriteLine("\n------示例：相等与比较运算符------\n");

            int x = Random.Shared.Next(100, 1000);
            int y = Random.Shared.Next(100, 1000);

			bool result = default;

            Console.WriteLine($"当前提供两个整数------ x：{x} | y：{y}");
            Console.WriteLine();

            //相等与不等运算符示例
            result = x == y;
			Console.WriteLine($"相等运算符示例------ x == y ：{result}");

			result = x != y;
			Console.WriteLine($"不等运算符示例------ x != y ：{result}");
            Console.WriteLine();

            //大于、小于运算符示例
            result = x > y;
            Console.WriteLine($"大于运算符示例------ x > y ：{result}");

            result = x < y;
            Console.WriteLine($"小于运算符示例------ x < y ：{result}");
            Console.WriteLine();

            //大于或等于、小于或等于运算符示例
            result = x >= y;
            Console.WriteLine($"大于或等于运算符示例------ x >= y ：{result}");

            result = x <= y;
            Console.WriteLine($"小于或等于运算符示例------ x <= y ：{result}");
			Console.WriteLine();
        }

        /*【11005：成员访问运算符】
			运算符	使用形式		名称					类别		功能作用									附加说明															可重载性

			.		x.y			成员访问运算符			主要		► 用于访问命名空间或类型的成员																				不可重载
															► 构成限定名称以访问命名空间中的类型

			()		f(x)		调用运算符			主要		► 用于调用被访问的方法或调用委托																				不可重载
								优先级调整运算符				► 用于调整运算的优先级顺序

			[]		a[i]		索引运算符			主要		► 用于访问数组元素或类型索引器																				不可重载，但可在用户自定义的类型中定义索引器来使类型支持使用 [] 进行索引
					[attribute]	特性指定运算符					► 用于为类型或其成员指定特性

			^		a[^i]		从末尾开始索引运算符	一元		► 指示元素位置来自序列的末尾					► 对于长度为 length 的序列，^n 指向与序列开头偏移 length - n 的元素		不可重载

			..		a[x..y]		范围运算符			二元		► 指定某一索引范围的开头和末尾作为其操作数		► 左侧操作数是范围的包含性开头，右侧操作数是范围的不包含性末尾				不可重载
																									► 可以省略 .. 运算符的任何操作数来获取无限制范围
		* ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		*/
		public static void LearnMemberAccessOperator()
		{
            Console.WriteLine("\n------示例：成员访问运算符------\n");

            List<int> list = new List<int>();
			int result = 0;

			//成员访问运算符示例：访问集合实例list的Add方法
			//调用运算符示例：调用Add方法
			for (int i = 0; i < 5; i++)
			{
				list.Add(Random.Shared.Next(100, 1000));
			}

			//索引运算符示例：使用索引访问集合实例list的元素
			//成员访问运算符和调用运算符示例：调用Console类的WriteLine方法输出每个元素
			Console.WriteLine("集合示例list中的元素：");

			for (int i = 0; i < list.Count; i++)
			{
				result = list[i];
				Console.WriteLine($"index：[{i}] ------ element：{result}");
			}
			Console.WriteLine();

            Console.WriteLine("集合示例list中的元素(从末尾索引)：");

            //从末尾开始索引运算符示例：从序列末尾开始索引其元素
            for (int i = 1;i <= list.Count;i++)
			{
				result = list[^i];
				Console.WriteLine($"index：[^{i}] ------ element：{result}");
            }
            Console.WriteLine();
            
            Console.WriteLine("集合示例list中的元素(索引范围---[1,4))：");

            //范围运算符示例：指定索引序列中的某个范围，范围属于左闭右开区间
            var childList = list[1..4];
			foreach (var item in childList) 
            {
                Console.WriteLine($"element：{item}");
            }
			Console.WriteLine();
        }

        /*【11006：Null运算符】
		 * ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			运算符	使用形式		名称						类别		功能作用																					附加说明															可重载性

			?.		x?.y		null条件成员访问运算符		主要		► 仅当操作数为非 null 时才用于执行成员访问运算													► 使用 ?. 运算符来检查委托是否非 null 并以线程安全的方式调用它			不可重载

			?[]		a?[i]		null条件索引运算符			主要		► 仅当操作数为非 null 时才用于执行索引运算																														不可重载

			!		x!			null包容运算符			主要		► 在已启用的可为空的注释上下文中，使用 null 包容运算符来取消上述表达式的所有可为 null 警告																				不可重载

			??		x??y		null合并运算符			二元		► 如果左操作数的值不为 null，则 null 合并运算符 ?? 返回该值；否则，它会计算右操作数并返回其结果		► 如果左操作数的计算结果为非 null，则 ?? 运算符不会计算其右操作数			不可重载
		 * ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		 */
        public static void LearnNullOperator()
		{
            Console.WriteLine("\n------示例：Null运算符------\n");

			List<int>? list = [1, 2, 3, 4, 5];
			List<int>? nullList = null;
            int? countElements = 0;

            //null条件成员访问运算符示例：访问集合实例nullList的Count属性，因为其为null，故不会访问Count属性，并且会返回一个null值。如使用常规方法访问，则会报错
            //null包容运算符示例：访问集合示例list的Count属性，使用null包容运算符来取消可为空的上下文中的null警告，因为前述代码中可知list不为空
			countElements = list!.Count;
            Console.WriteLine($"集合实例list的元素计数为：{countElements}");

			countElements = nullList?.Count;
			Console.WriteLine($"集合实例nullList的元素计数为：{(countElements is not null ? countElements : "null")}");
			Console.WriteLine();

			//null条件索引运算符示例：仅当操作数为非null时执行索引
			Console.WriteLine("输出集合实例list的元素：");
			for (int i = 0; i < list?.Count; i++)
			{
				Console.WriteLine($"index：[{i}] ------ element：{list?[i]}");
			}
            Console.WriteLine();

            Console.WriteLine("输出集合实例nullList的元素：");
            for (int i = 0; i < nullList?.Count; i++)
            {
                Console.WriteLine($"index：[{i}] ------ element：{nullList?[i]}");
            }
			Console.WriteLine();

			//nul合并运算符：如果左操作数的值不为 null，则 null 合并运算符 ?? 返回该值；否则，它会计算右操作数并返回其结果
			List<int> resultList = nullList ?? list!;

			Console.WriteLine("输出集合实例resultList的元素：");
			for (int i = 0; i <  resultList.Count ; i++)
			{
                Console.WriteLine($"index：[{i}] ------ element：{nullList?[i]}");
            }
			Console.WriteLine();
        }

        /*【110007：集合表达式运算符】
		 * ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			运算符	使用形式			名称				类别		功能作用										附加说明						可重载性

			[]		[elements]		集合表达式运算符	主要		► 使用集合表达式来创建常见的集合值。				elements表示元素的序列			不可重载

			..		..collection	分布元素运算符		一元		► 使用分布元素 .. 在集合表达式中内联集合值。		collection表示任意集合变量		不可重载
		 * ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		 */
        public static void LearnCollectionExpressionOperator()
		{
            Console.WriteLine("\n------示例：集合表达式运算符------\n");

			//集合表达式运算符示例：使用集合表达式初始化集合、数组
			int[] primenumbersArray = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41];
			List<int> primenumbersList = [43, 47, 53, 59, 61, 67, 71, 73, 79, 83];

			//分布元素运算符示例：利用分布元素运算符和集合表达式，可以简便的将已有集合内联来初始化新集合
			List<int> primenumbers = [.. primenumbersArray, .. primenumbersList, 89, 97];

			Console.WriteLine($"100以内的质数：{string.Join('，', primenumbers)}\n");
        }

        /*【11008：类型测试与强制转换运算符】
		 * ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			运算符	使用形式			名称				类别		功能作用															附加说明																									可重载性

			is		x is type		is 运算符			二元		► 检查表达式结果的运行时类型是否与给定类型兼容							► 左操作数不得为匿名方法或Lambda表达式																		不可重载
					x is type y								► 对照某个模式测试表达式结果											► is运算符不会考虑用户定义的转换
																															► 如果表达式结果为非 null 并且满足以下任一条件，则 is 运算符将返回 true：
																																• 表达式结果的运行时类型为 type
																																• 表达式结果的运行时类型派生自类型 type、实现接口 type，或者存在从其到 type 的另一种隐式引用转换
																																• 表达式结果的运行时类型是基础类型为 type 且 Nullable<T>.HasValue 为 true 的可为空值类型
																																• 存在从表达式结果的运行时类型到类型 type 的装箱或取消装箱转换
																															► 作为模式匹配时，当 is 运算符返回 true 时可将左操作数的值赋予 type 类型的变量 y 

			as		x as type		as 运算符			二元		► 将表达式结果显式转换为给定的引用或可以为 null 值的类型					► 如果无法进行转换，则 as 运算符返回 null																		不可重载
																															► 与强制转换表达式不同，as 运算符永远不会引发异常
																															► as 运算符仅考虑引用、可以为 null、装箱和取消装箱转换，不能使用 as 运算符执行用户定义的转换

			typeof	typeof(x)		typeof 运算符		主要		► 用于获取某个类型的 System.Type 实例								► typeof 运算符的实参必须是类型或类型形参的名称																	不可重载
																															► 参数不能是需要元数据注释的类型：dynamic、任何可为 null 的引用类型
																															► 表达式不能为 typeof 运算符的参数。 若要获取表达式结果的运行时类型的 System.Type 实例，请使用 Object.GetType 方法

			()		(type)x			强制类型转换运算符	主要		► 形式为 (type)x 的强制转换表达式将表达式 x 的结果显式转换为类型 type		► 如果不存在从x的类型到类型 type 的显式转换，则发生编译时错误														不可重载，但可以定义可由强制转换表达式执行的自定义类型转换
		 * ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		 */
        public static void LearnTypeTestingAndCastOperator()
		{
            Console.WriteLine("\n------示例：类型测试与强制转换运算符------\n");

			object obj = Random.Shared.Next(100,1000) + Random.Shared.NextDouble();

            //is 运算符示例1：检查表达式结果的运行时类型是否与给定类型
			bool objIsDouble = obj is double;
			Console.WriteLine($"object实例obj实际上是否是double类型：{objIsDouble}");
			Console.WriteLine();

            //is 运算符示例2：对照某个模式测试表达式结果------以声明模式为例
			if(obj is double num)
				Console.WriteLine($"object实例obj实际类型：{obj.GetType()} ------ 值：{num}");
			Console.WriteLine();

			//as 运算符示例：将表达式结果显式转换为给定的引用或可以为 null 值的类型
			double? doubleNum = obj as double?;
			if (doubleNum.HasValue)
				Console.WriteLine($"object实例obj实际类型：{obj.GetType()} ------ 值：{doubleNum}");
			Console.WriteLine();

			//强制类型转换运算符示例：形式为 (type)x 的强制转换表达式将表达式 x 的结果显式转换为类型 type
			int intNum = (int)(double)obj;
            Console.WriteLine($"object实例obj强制转换为类型：{intNum.GetType()} ------ 值：{intNum}");
            Console.WriteLine();

			//typeof 运算符示例：获取某个类型的System.Type实例，以获取double类型的Type实例来获取其完全限定名为例
			var type = typeof(double);
			Console.WriteLine($"double类型的完全限定名：{type.FullName}");
			Console.WriteLine();
        }

        /*【11009：赋值运算符】
		 * ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			运算符	使用形式	名称							类别		功能作用													附加说明															可重载性
																
			=		x=y			赋值运算符 				二元		► 将其右操作数的值赋给变量、属性或由其左操作数给出的索引器元素		► 赋值表达式的结果是分配给左操作数的值									不可重载
																														► 右操作数类型必须与左操作数类型相同，或可隐式转换为左操作数的类型
																
			*=		x*=y		乘法复合赋值运算符			二元		► 等价于 左操作数 = 左操作数 * 右操作数																						可隐式重载，重载 * 时自动重载
																
			/=		x/=y		除法复合赋值运算符			二元		► 等价于 左操作数 = 左操作数 / 右操作数																						可隐式重载，重载 / 时自动重载
																
			%=		x%=y		取余复合赋值运算符			二元		► 等价于 左操作数 = 左操作数 % 右操作数																						可隐式重载，重载 % 时自动重载
																
			+=		x+=y		加法复合赋值运算符			二元		► 等价于 左操作数 = 左操作数 + 右操作数																						可隐式重载，重载 + 时自动重载
																► 用于在多播委托中组合委托
																► 用于在事件中订阅事件
																
			-=		x-=y		减法复合赋值运算符			二元		► 等价于 左操作数 = 左操作数 - 右操作数																						可隐式重载，重载 - 时自动重载
																► 用于在多播委托中删除委托
																► 用于在事件中取消订阅事件
																
			&=		x&=y		(位)逻辑与复合赋值运算符		二元		► 等价于 左操作数 = 左操作数 & 右操作数																						可隐式重载，重载 & 时自动重载
																
			|=		x|=y		(位)逻辑或复合赋值运算符		二元		► 等价于 左操作数 = 左操作数 | 右操作数																						可隐式重载，重载 | 时自动重载
																
			^=		x^=y		(位)逻辑异或复合赋值运算符	二元		► 等价于 左操作数 = 左操作数 ^ 右操作数																						可隐式重载，重载 ^ 时自动重载
																
			<<=		x<<=y		左移位复合赋值运算符		二元		► 等价于 左操作数 = 左操作数 << 右操作数																						可隐式重载，重载 << 时自动重载
																
			>>=		x>>=y		右移位复合赋值运算符		二元		► 等价于 左操作数 = 左操作数 >> 右操作数																						可隐式重载，重载 >> 时自动重载
																
			>>>=	x>>>=y		无符号右移位复合赋值运算符	二元		► 等价于 左操作数 = 左操作数 >>> 右操作数																						可隐式重载，重载 >>> 时自动重载
																
			??=		x??=y		null合并复合赋值运算符		二元		► 等价于 左操作数 = 左操作数 ?? 右操作数																						不可重载
		 * ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		 */
        public static void LearnAssignmentOperator()
		{
            Console.WriteLine("\n------示例：赋值运算符------\n");
			int refX = Random.Shared.Next(100, 1000);
			int? x = refX;
			int? y = Random.Shared.Next(100, 1000); ;
			int shiftCounts = 3;
			int? result = 0;

            Console.WriteLine($"当前提供两个整数，并显示其二进制值\nx：十进制------ {x,-3} | 二进制------ {x:b32}\ny：十进制------ {y,-3} | 二进制------ {y:b32}");

            //赋值运算符示例
            result = x;
            Console.WriteLine($"赋值运算符示例 || result = x ------ result：{result}");
            Console.WriteLine();

			//乘法、除法、取余复合运算符示例
			x *= y;
			Console.WriteLine($"乘法复合赋值运算符示例 || x *= y ------ x：{x}");

			x = refX;
			x /= y;
            Console.WriteLine($"除法复合赋值运算符示例 || x /= y ------ x：{x}");

            x = refX;
            x %= y;
            Console.WriteLine($"取余复合赋值运算符示例 || x %= y ------ x：{x}");
			Console.WriteLine();

            //加法、减法复合运算符示例
			x = refX;
            x += y;
            Console.WriteLine($"加法复合赋值运算符示例 || x += y ------ x：{x}");

            x = refX;
            x -= y;
            Console.WriteLine($"减法复合赋值运算符示例 || x -= y ------ x：{x}");
			Console.WriteLine();

			//(位)逻辑与、或、异或复合赋值运算符示例
			x = refX;
			x &= y;
			Console.WriteLine($"(位)逻辑与  复合赋值运算符示例 || x &= y ------ x：十进制结果--- {x,-3} | 二进制结果--- {x:b32}");

            x = refX;
            x |= y;
            Console.WriteLine($"(位)逻辑或  复合赋值运算符示例 || x |= y ------ x：十进制结果--- {x,-3} | 二进制结果--- {x:b32}");

            x = refX;
            x ^= y;
            Console.WriteLine($"(位)逻辑异或复合赋值运算符示例 || x ^= y ------ x：十进制结果--- {x,-3} | 二进制结果--- {x:b32}");
            Console.WriteLine();

            //移位复合赋值运算符示例
            x = refX;
            x <<= shiftCounts;
            Console.WriteLine($"左移位复合赋值运算符示例 || x <<= {shiftCounts} ------ x：十进制结果--- {x} | 二进制结果--- {x:b32}");

            x = refX;
            x >>= shiftCounts;
            Console.WriteLine($"右移位复合赋值运算符示例 || x >>= {shiftCounts} ------ x：十进制结果--- {x} | 二进制结果--- {x:b32}");

            x = refX;
            x >>>= shiftCounts;
            Console.WriteLine($"无符号右移位复合赋值运算符示例 || x >>>= {shiftCounts} ------ x：十进制结果--- {x} | 二进制结果--- {x:b32}");
            Console.WriteLine();

            //null合并复合赋值运算符示例
			x = refX;
			x ??= y;
			Console.WriteLine($"null合并复合赋值运算符示例 || x ??= y ------ x：{x}");
            Console.WriteLine();

        }

        /*【11010：三元条件运算符】
		 * ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			运算符	使用形式		名称				类别		功能作用																				附加说明												可重载性

			?:		bool?x:y	三元条件运算符		三元		用于计算布尔表达式，并根据布尔表达式的计算结果为 true 还是 false 来返回两个表达式中的一个结果		当 bool 为 true 时，返回 x 的结果，否则返回 y 的结果		不可重载
		 * ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		 */
        public static void LearnConditionalOperator()
		{
            Console.WriteLine("\n------示例：三元条件运算符------\n");

			input1:
			Console.Write("请输入第一个整数：");
			if(!int.TryParse(Console.ReadLine(),out int number1))
				goto input1;
			Console.WriteLine();

            input2:
            Console.Write("请输入第二个整数：");
            if (!int.TryParse(Console.ReadLine(), out int number2))
                goto input2;
			Console.WriteLine();

			//三元条件运算符示例：比较两个整数大小并返回较大的一个
			int maxNumber = number1 > number2 ? number1 : number2;

			Console.WriteLine($"{number1} 和 {number2} 之间的较大数为：{maxNumber}");
			Console.WriteLine();
        }

        /*【11011：匿名函数与Lambda表达式运算符】
		 * ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			运算符		使用形式							名称				类别		功能作用																		附加说明																						可重载性

			delegate	delegate(params){statements}	匿名函数运算符		主要		► 创建一个可以转换为委托类型的匿名方法												► 匿名方法可以转换为 System.Action 和 System.Func<TResult> 等类型，用作许多方法的参数				不可重载
																																							► 使用 delegate 运算符时，可以省略参数列表，这样做可以将创建的匿名方法转换为具有任何参数列表的委托类型

			=>			► (params)=>{statements}		Lambda运算符		二元		► 在 lambda 表达式中，lambda 运算符 => 将左侧的输入参数与右侧的 lambda 主体分开																									不可重载
						► member => expression									► 作为成员名称的分隔符和表达式主体定义中的成员实现
		 * ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		 */
        public static void LearnAnonymousFuncAndLambdaOperator()
		{
            Console.WriteLine("\n------示例：匿名函数与Lambda表达式运算符------\n");
			
			//匿名函数运算符示例1
			Action anonymousAction = delegate
			{
				Console.WriteLine("这是一个匿名函数的输出！");
			};

            //匿名函数运算符示例2：使用 delegate 运算符时，可以省略参数列表，这样做可以将创建的匿名方法转换为具有任何参数列表的委托类型
            Func<string,string> anonymousFunc = delegate
			{
				return "这是一个匿名函数的输出！";
            };

			//Lambda运算符示例1：
			Action action = () => Console.WriteLine("这是一个Lambda表达式的输出！");

			//Lambda运算符示例2：
			Func<string, string> func = (str) => $"这是一个Lambda表达式的输出！并且包含参数的输入：{str}";

            //Lambda运算符示例3：表达式主体定义----如需了解请在 [C# 学习--基础篇] 章节中选择以下章节进行了解：019 表达式主体成员定

            anonymousAction.Invoke();
            Console.WriteLine(anonymousFunc.Invoke(""));
			action.Invoke();
			Console.WriteLine(func.Invoke("哈哈哈")); 
			Console.WriteLine();
		}

        /*【11012：指针相关运算符】
		 * ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			运算符	使用形式		名称					类别		功能作用												附加说明																													可重载性

			&		&x			Address-of 运算符		一元		► 返回其操作数的地址									► 通常操作数必须是固定变量： 固定变量是驻留在不受垃圾回收器操作影响的存储位置的变量													不可重载
																												► 如果使用 fixed 语句“固定”，则可以获取可移动变量的地址：驻留在可能受垃圾回收器影响的存储位置的变量（如重定位）称为可移动变量
																												► 无法获取常量或值的地址

			*		*x			指针间接运算符			一元		► 获取其操作数指向的变量									► 操作数必须是指针类型																										不可重载
																												► 不能将 * 运算符应用于类型 void* 的表达式

			->		x->y		指针成员访问运算符		主要		► 将指针间接和成员访问合并								► 如果 x 是类型为 T* 的指针且 y 是类型 T 的可访问成员，则 x->y 形式的表达式等效于 (*x).y											不可重载

			[]		p[n]		指针元素访问运算符		主要		► 对于指针类型的表达式 p，p[n] 形式的指针元素访问计算		► 不能将 [] 用于带有类型为 void* 的表达式的指针元素访问																			不可重载
															  方式为 *(p + n)，其中 n 必须是可隐式转换为 int、uint、
															  long 或 ulong 的类型
		 * ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		 */
        public static void LearnPointerOperator()
		{
            Console.WriteLine("\n------示例：指针相关运算符------\n");

			input:
			Console.Write("请输入任意一段话后按Enter键提交：");
			Console.WriteLine();

			string? inputString = Console.ReadLine();
			
			if(string.IsNullOrWhiteSpace(inputString))
				goto input;

			unsafe
            {
                //指针间接运算符示例
                char* ptrChar;
				 
				fixed (char* ptrString = inputString)
				{
					Console.WriteLine($"获取输入字符串的起始地址：{(long)ptrString}");
					for (int i = 0;	i < inputString.Length; i++)
					{
						ptrChar = &ptrString[i];
						Console.WriteLine($"输入字符串的第 {i + 1:00} 个字符为：{*ptrChar}，其地址为{(long)ptrChar}");
                    }
				}
			}

            Console.WriteLine();
        }

		/*【11013：其他主要节点运算符】
		 * ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			运算符		使用形式				名称				类别		功能作用															附加说明																												可重载性

			new			new(params)			new 运算符		主要		► 通过调用类型的某个构造函数创建类型的新实例							► 可以使用带有 new 运算符的对象或集合初始值设定项实例化和初始化一个语句中的对象													不可重载，但可以通过重载构造函数实现类型的个性化实例化方式
																	► 创建数组实例														► 构造调用表达式由目标确定类型：如果已知表达式的目标类型，则可以省略类型名称
																																	► 要创建匿名类型的实例，请使用 new 运算符和对象初始值设定项语法

			default		default(type)		默认值运算符		主要		► 生成类型的默认值													► default 运算符的实参必须是类型或类型形参的名称	不可重载
																	► 当编译器可以推断表达式类型时，可以使用 default 文本生成类型的默认值		► default 文本生成与 default(type) （其中，type 是推断的类型）相同的值。 可在以下任一情况下使用 default 文本：
																																		 • 对变量进行赋值或初始化时
																																		 • 在声明可选方法参数的默认值时
																																		 • 在方法调用中提供参数值时
																																		 • 在 return 语句中或作为表达式主体成员中的表达式时

			checked		checked(x)			上下文检查运算符	主要		► 控制溢出检查上下文，在该上下文中将计算一个表达式						► 在已检查的上下文中，如果在常数表达式中发生溢出，则会发生编译时错误。 否则，当在运行时执行此运算时，则引发 OverflowException			不可重载，但重载算术运算符时，可以使用 checked 关键字定义该运算符的已检查版本
																																																															• 定义已检查的运算符时，还必须定义不带 checked 修饰符的相应运算符
			
			unchecked	unchecked(x)		上下文检查运算符	主要		► 控制溢出检查上下文，在该上下文中将计算一个表达式						► 在未检查的上下文中，会通过丢弃任何不适应目标类型的高序位来将结果截断															不可重载
																																	► 默认情况下，算术运算发生在 unchecked 上下文中

			nameof		nameof(x)			nameof运算符		主要		► 可生成变量、类型或成员的名称作为字符串常量							► nameof 表达式在编译时进行求值，在运行时无效																				不可重载
																	► 使用 nameof 表达式使参数检查代码更易于维护							► 当操作数是类型或命名空间时，生成的名称不是完全限定的
																																	► 当操作数是逐字标识符时， @ 该字符不是名称的一部分

			sizeof		sizeof(type)		sizeof运算符		主要		► 返回给定类型的变量所占用的字节数									► sizeof 运算符的参数必须是一个非托管类型的名称，或是一个限定为非托管类型的类型参数												不可重载
																																	► sizeof 运算符返回公共语言运行时将在托管内存中分配的字节数，对于结构类型，该值包括了填充（如有）
																																	► sizeof 运算符需要不安全上下文，但以下情况除外：
																																		 • 除nint和unint以外的C#内置值类型
																																		 • 枚举类型

			stackalloc	stackalloc type[i]	栈分配运算符		主要		► 在堆栈上分配内存块												► 当包含stackalloc方法返回时，将自动丢弃在方法执行期间创建的已分配堆栈内存块													不可重载
																																	► 不能显式释放使用 stackalloc 分配的内存
																																	► 堆栈中分配的内存块不受垃圾回收的影响，也不必通过 fixed 语句固定
																																	► 可以将 stackalloc 表达式的结果分配给以下任一类型的变量：
																																	        · System.Span<T> 或 System.ReadOnlySpan<T>
																																	                ○ 将堆栈中分配的内存块分配给 或 Span<T> 变量时，不必使用 ReadOnlySpan<T> 上下文
																																	                ○ 只要允许使用 stackalloc 或 Span<T> 变量，就可以在其他表达式中使用 ReadOnlySpan<T> 表达式或集合表达式
																																	        · 指针类型
																																	                ○ 使用指针类型时必须使用 unsafe 上下文
																																	                ○ 对于指针类型，只能在局部变量声明中使用 stackalloc 表达式来初始化变量
																																	► 堆栈上可用的内存量存在限制。 如果在堆栈上分配过多的内存，会引发 StackOverflowException：
																																	        · 限制使用 stackalloc 分配的内存量
																																	        · 避免在循环内使用 stackalloc。 在循环外分配内存块，然后在循环内重用它
		 * ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		 */
		public static void LearnOtherPrimaryOperator()
		{
            Console.WriteLine("\n------示例：其他主要节点运算符------\n");

			//new运算符示例：创建类型实例和数组实例
			Point point = new Point();
			point.X = Random.Shared.Next(-999, 1000);
            point.Y = Random.Shared.Next(-999, 1000);
			Console.WriteLine($"输出Point实例point信息 --- {point}");
			Console.WriteLine();

			int[] ints = { 1, 3, 5, 7, 9, 11, 13, 15, 17, 19 };
			Console.WriteLine($"输出数组实例ints元素：{string.Join<int>('，', ints)}");
			Console.WriteLine();

			//default运算符示例：为类型生成默认值，可通过default表达式或default文本实现
			int defaultIntValue = default(int);
			bool defaultBoolValue = default;

			Console.WriteLine($"类型： int | 默认值：{defaultIntValue}");
			Console.WriteLine($"类型：bool | 默认值：{defaultBoolValue}");
			Console.WriteLine();

			//checked和unchecked运算符示例
			int maxIntValue = int.MaxValue;
			int number = 0;
            try 
			{
				number = checked(maxIntValue + 1);
			}
			catch (Exception e)
			{
                Console.WriteLine($"checked运算符示例---无法计算变量number的值，错误：{e.Message}");
			}

			number = unchecked(maxIntValue + 1);
			Console.WriteLine($"unchecked运算符示例---计算变量number的值：{number}");
			Console.WriteLine();

			//nameof运算符示例：
			string variableName = nameof(number);

			Console.WriteLine($"变量number的名称为：{variableName}");
			Console.WriteLine();

			//sizeof运算符示例
			int sizeofInt =  sizeof(int);

            Console.WriteLine($"【int类型】对应.NET的 {typeof(int)} 类型 | 它表示内存占用{sizeofInt:00}字节的整数");
            Console.WriteLine();

			//栈分配运算符示例
			unsafe
			{
				int* intPtr = stackalloc int[] { 1, 3, 5, 7, 9, 11, 13, 15, 17, 19 };

                Console.WriteLine("数组实例spanInts中元素信息：");
				for (int i = 0; i < 10; i++)
				{
					Console.WriteLine($"index[{i:00}] -- value：{intPtr[i],-2} -- address：{(long)&intPtr[i]}");
				}
			}
			Console.WriteLine();
        }

        /*【11014：其他一元运算符】
		 * ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			运算符		使用形式					名称				类别		功能作用															附加说明																										可重载性

			await		await task				异步等待运算符		一元		► 会暂停包含它的异步方法的执行，直到其操作数所表示的异步操作完成			► 当异步操作完成时，await运算符会返回操作的结果（如果有）																不可重载
																																		► 如果await运算符应用于一个已经完成的操作数，它会立即返回操作的结果，而不会暂停包含的方法
																																		► await运算符不会阻塞执行异步方法的线程。当await运算符暂停包含的异步方法时，控制权会返回给调用该方法的调用者
																																		► 只能在用async关键字修饰的方法、lambda表达式或匿名方法中使用await运算符
																																		► 在异步方法中，你不能在同步局部函数的主体中、lock语句块内或不安全上下文中使用await运算符
																																		► await操作符的操作数通常是以下.NET类型之一：Task、Task<TResult>、ValueTask或ValueTask<TResult>
																																		        • 任何可等待表达式都可以作为await操作符的操作数
																																		► 可以使用await foreach语句来消费异步数据流，可以使用await using语句来处理异步可释放对象

			true		将对象实例作为bool表达式	true运算符		一元		► 返回 bool 值 true 来指示其操作数一定为 true						► “此对象是否为 true？”解析为运算符 true。 如果对象为 true，运算符 true 将返回 true。 应答为“是，此对象为 true”			可重载，但必须同时重载 false 运算符
																																		► 无法确保 true 和 false 运算符互补

			false		将对象实例作为bool表达式	false运算符		一元		► 返回 bool 值 true 来指示其操作数一定为 false						► “此对象是否为 false？”解析为运算符 false。 如果对象为 false，运算符 false 将返回 true。 应答为“是，此对象为 false”		可重载，但必须同时重载 true 运算符
																																		► 无法确保 true 和 false 运算符互补
		 * ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		 */
        public static void LearnOtherUnaryOperator()
		{
            Console.WriteLine("\n------示例：异步等待运算符------\n");

			//异步等待运算符：使用一个局部异步方法来示例await运算符，这里使用async void是为了方便示例，通常除了WinForm、WPF的元素响应事件外不会这样使用
			async void OutputCurrentTime()
			{
				DateTime maxtime = DateTime.Now.AddSeconds(30);
				while (DateTime.Now < maxtime)
				{
                    Console.WriteLine(DateTime.Now);
                    await Task.Delay(1000);
                } 
			}

			OutputCurrentTime();
			Thread.Sleep(30000);
            Console.WriteLine();

            Console.WriteLine("\n------示例：true 和 false运算符------\n");

            //true、false运算符示例：由于内部结构Point中重载了这两个运算符，所以以该结构示例为例进行演示
            Point point = new Point() { X = Random.Shared.Next(-999, 1000), Y = Random.Shared.Next(-999, 1000) };

			//可以将示例直接解析为bool值
			if(point)
                Console.WriteLine($"横纵坐标均为正整数 ---{point}");
			else
                Console.WriteLine($"横纵坐标存在负整数 ---{point}");

            Console.WriteLine();
        }

        /*【11015：switch和with运算符】
		 * ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			运算符		使用形式					名称				类别		功能作用																附加说明													可重载性

			switch		x switch {patterns}		switch运算符		-		根据与输入表达式匹配的模式，对候选表达式列表中的单个表达式进行求值																		不可重载

			with		x with {}				with运算符		-		使用修改的特定属性和字段生成其操作数的副本									使用 对象初始化器 语法来指定要修改的成员以及它们的新值			不可重载
																																			左侧操作数可以是一个记录类型、结构类型或匿名类型
																																			结果与表达式的操作数具有相同的运行时类型
																																			对于引用类型成员，在复制操作数时仅复制对成员实例的引用， 复制和原始操作数都有权访问同一引用类型实例
		 * ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		 */
		public static void LearnSwitchAndWithOperator()
		{
            Console.WriteLine("\n------示例：switch和with运算符------\n");

			List<int> intList = new List<int>(50);
			string intInfo = "";

			for (int i = 0; i < 50; i++)
			{
				intList.Add(Random.Shared.Next(int.MinValue, int.MaxValue));
			}

            Console.WriteLine("已创建一个包含50个随机数字的整数集合，输出每个数字的值和其正负与奇偶：");
			for (int i = 0; i < 50; i++)
			{
				//switch运算符示例:以case-when模式为示例
				intInfo = intList[i] switch
				{
					int num when num < 0 && num % 2 != 0 => $"index[{i:00}]：{num,-11} --------- 负数 | 奇数",
                    int num when num < 0 && num % 2 == 0 => $"index[{i:00}]：{num,-11} --------- 负数 | 偶数",
                    int num when num > 0 && num % 2 != 0 => $"index[{i:00}]：{num,-11} --------- 正数 | 奇数",
                    int num when num > 0 && num % 2 == 0 => $"index[{i:00}]：{num,-11} --------- 正数 | 偶数",
					_ => $"index[{i:00}]：{intList[i],-11} ---------   零 | 偶数"
                };
				Console.WriteLine(intInfo);
			}
            Console.WriteLine();

			//-------------------------------------------------------------------------------------------------------------------------------------

			Point pointOrigin = new Point();
			pointOrigin.X = 25;
			pointOrigin.Y = 25;

			//with运算符示例：以内部结构Point为例进行代码演示
			Point pointWithoutChanged = pointOrigin with { };
			Point pointWithChanged = pointOrigin with { X = -25, Y = -25 };

            Console.WriteLine($"输出结构pointOrigin信息，并且输出使用with表达式基于其生成的结构pointWithoutChanged和pointWithChanged的信息：");
            Console.WriteLine(pointOrigin);
            Console.WriteLine(pointWithoutChanged);
            Console.WriteLine(pointWithChanged);
            Console.WriteLine();
        }

        /*【11016：重载运算符】
		 * ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
			运算符		使用形式													名称					功能作用												附加说明

			operator	pubic static 返回类型 operator 运算符(参数列表){}			重载运算符			用于重载预定义的 C# 运算符								必须同时包含 public 和 static 修饰符

			implicit	pubic static implicit operator 目标类型(原类型 变量){}		用户定义隐式转换		在用户定义类型中定义从或到另一个类型的自定义隐式转换			必须同时包含 public 和 static 修饰符，且必须同时使用 operator 操作符

			explicit	pubic static explicit operator 目标类型(原类型 变量){}		用户定义显示转换		在用户定义类型中定义从或到另一个类型的自定义显1式转换			必须同时包含 public 和 static 修饰符，且必须同时使用 operator 操作符
		 * ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		 */
		public static void LearnOperatorOverload()
		{
            Console.WriteLine("\n------示例：运算符重载------\n");

            //具体重载示例代码请看本页定义的内部结构Point，该结构表示平面坐标系中的坐标点
            //本方法内示例为使用重载的运算符

            Point point1 = new Point() { X = Random.Shared.Next(-999, 1000), Y = Random.Shared.Next(-999, 1000) };
            Point point2 = new Point() { X = Random.Shared.Next(-999, 1000), Y = Random.Shared.Next(-999, 1000) };

			var pointDistance = point1 - point2;
			Console.WriteLine($"Point1 --- {point1}\nPoint2 --- {point2}\n距离：{pointDistance}");

			Console.WriteLine();
        }


		//定义一个内部Point类来进行自定义运算符重载实现的示例
		//关于类我们后续会详细说明，这里只用知道这是我们自定义的一个类型
        private struct Point
		{
			//声明并定义两个属性表示坐标点的X和Y值
			public int X { get; set; }
			public int Y { get; set; }

			//自定义一个隐式类型转换，可以将Point类型隐式转换成(double,double)元组类型
			public static implicit operator (double,double)(Point point)
			{
				return (point.X, point.Y);
			}

			//自定义一个显示类型转换，可以将(double, double)元组类型强制转换为Point类型
			public static explicit operator Point((double,double) pointTuple)
			{
				return new Point() { X = (int)pointTuple.Item1, Y = (int)pointTuple.Item2 };
			}

			//重载一个二元-的实现用于计算两个Point类型表示的坐标点的距离
			public static double operator -(Point pointLeft,Point pointRight) 
			{
				double subX = pointLeft.X - pointRight.X;
				double subY = pointLeft.Y - pointRight.Y;

				return Math.Sqrt(subX * subX + subY * subY);
			}

			//重载一个一元-的实现用于返回Point类型表示的坐标点关于原点的对称点
			public static Point operator -(Point point)
			{
				return new Point() { X = -point.X, Y = -point.Y };
			}

			//重载一对特殊的一元运算符true/false
			public static bool operator true(Point point)
			{
				return point.X > 0 && point.Y > 0;
			}
			public static bool operator false(Point point)
			{
				return !(point.X > 0 && point.Y > 0);
			}

            public override string ToString()
            {
				return $"Point --- Value：(X:{X}，Y:{Y}) | HashCode：{this.GetHashCode()}";
            }
        }


        public static void StartLearnOperatorAndExpression()
        {
            string title = "001 算术运算符符\n" +
                "002 布尔逻辑运算符\n" +
                "003 位运算符和移位运算符\n" +
                "004 相等和比较运算符\n" +
                "005 成员访问运算符\n" +
                "006 Null运算符\n" +
                "007 集合表达式运算符\n" +
                "008 类型测试与强制转换运算符\n" +
                "009 赋值运算符\n" +
                "010 三元条件运算符\n" +
                "011 匿名函数与Lambda表达式运算符\n" +
                "012 指针相关运算符\n" +
                "013 其他主要节点运算符\n" +
                "014 其他一元运算符\n" +
                "015 Switch和With与运算符\n" +
                "016 运算符重载\n";

            do
            {
                Console.WriteLine("【学习运算符和表达式】");
                Console.WriteLine(title);
                Console.Write("请输入上列编号（如001）查看对应知识点代码运行结果：");

                string? input = Console.ReadLine();

                Console.WriteLine();

                switch (input)
                {
                    case "001": LearnArithmeticOperator(); break;
                    case "002": LearnBooleanLogicalOperator(); break;
                    case "003": LearnBitwiseAndShiftOperator(); break;
                    case "004": LearnEqualityAndComparisonOperator(); break;
                    case "005": LearnMemberAccessOperator(); break;
                    case "006": LearnNullOperator(); break;
                    case "007": LearnCollectionExpressionOperator(); break;
                    case "008": LearnTypeTestingAndCastOperator(); break;
                    case "009": LearnAssignmentOperator(); break;
                    case "010": LearnConditionalOperator(); break;
                    case "011": LearnAnonymousFuncAndLambdaOperator(); break;
                    case "012": LearnPointerOperator(); break;
                    case "013": LearnOtherPrimaryOperator(); break;
                    case "014": LearnOtherUnaryOperator(); break;
                    case "015": LearnSwitchAndWithOperator();break;
                    case "016": LearnOperatorOverload(); break;
                    default: Console.WriteLine("输入错误！"); break;
                }

                Console.WriteLine();
                Console.WriteLine("是否继续查询和运行本章节其他代码：直接按下Enter继续，否则即退出");

                if (Console.ReadKey(true).Key != ConsoleKey.Enter)
                    break;
                Console.WriteLine("\n");
            }
            while (true);
        }
    }
}
