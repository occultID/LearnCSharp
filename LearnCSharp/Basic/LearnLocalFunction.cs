/*【学习本地函数】
 * 本地函数
	• 本地函数是一种嵌套在另一成员中的方法
	• 仅能从包含本地函数的成员中调用本地函数
	• 可以在以下位置中声明和调用本地函数
		○ 方法（尤其是迭代器方法和异步方法）
		○ 构造函数
		○ 属性访问器
		○ 事件访问器
		○ 匿名方法
		○ Lambda表达式
		○ 终结器
		○ 其他本地函数
	• 不能在expression-bodied成员中声明本地函数
	• 本地函数不支持重载

 * 本地函数语法
	• 本地函数被定义为包含成员中的嵌套方法，其声明语法如下：
		○ 有效的方法修饰符组合 返回类型 方法名称( 参数列表 ) {}
			§ 有效的方法修饰符组合：该项是可选配置，根据需求选择使用以下任意修饰组合
				□ 无：不需要任何修饰的声明
				□ async：声明该本地函数为异步方法
				□ unsafe：声明该本地函数为不安全方法，其返回类型或内部实现会使用非托管类型
				□ static：声明该方法为静态本地函数，其内部无法捕获局部变量或实例状态
				□ extern：外部本地函数必须为static
			§ 返回类型：该项为必选配置
				□ 要求同常规方法
			§ 方法名称：该项为必选配置
				□ 要求同常规方法
			§ ()：该项为必选配置
				□ 要求同常规方法
			§ 参数列表：该项为可选配置
				□ 要求同常规方法
			§ {}：该项为半可选配置
				□ 花括号内部为方法实现的代码
				□ 使用extern修饰符声明时该项不可选
				□ 其余情况该项必选
		○ 包含成员中定义的所有本地变量均可在非静态本地函数中访问
		○ 本地函数的声明定义不能包含访问级别

 * 本地函数的作用
	• 重新组织整理方法逻辑代码提升可读性与易读性
		○ 当方法体逻辑复杂且代码繁多，又必须保障不拆分方法时，可用本地函数对逻辑代码进行重新组织整理
		○ 当使用Lambda表达式作为委托实例而Lambda表达式代码块繁多时可改为使用本地函数组织逻辑并将本地函数作为委托实例
	• 允许立即显示异常
		○ 对于迭代器，仅在枚举返回序列时才显示异常，而本地函数可使其在检索迭代器时立即显示异常
		○ 对于异步方法，在等待返回的任务时，利用本地函数将观察到异步方法中引发的异常

 * 本地函数与Lambda表达式 --Lambda表达式类容参考LearnLambda部分和LearnLambdaCatchLoopVariables部分
	• 本地函数与Lambda表达式许多情况下可由开发者自行考虑选择使用
	• 区别
		○ 声明和命名
			§ 本地函数的声明和命名方式与常规方法几乎相同
			§ Lambda表达式是一种匿名方法，需要分配给委托（delegate）类型的变量
			§ 本地函数可以独立声明和使用，Lambda表达式需要先赋值于委托再由委托来调用
		○ 函数签名与Lambda表达式类型
			§ 本地函数需要明确指定返回类型和参数类型（如有）
			§ Lambda表达式可以根据委托类型来自行推断其返回类型和参数类型
		○ 明确赋值
			§ 本地函数在编译时定义
				□ 可以在定义本地函数的块内任意位置调用本地函数
				□ 当成员内部有功能需要使用递归来实现时，本地函数是一个不错的选择
			§ Lambda表达式是在运行时分配对象
				□ Lambda表达式不能直接单独定义
				□ 必须先声明并定义一个委托类型实例，并将Lambda表达式赋值给该实例
		○ 实现为委托
			§ 本地函数可以直接调用，也可在包含成员内部赋值于类型兼容的委托
			§ Lambda表达式在声明时即要求转换为类型兼容的委托实例
		○ 外部变量捕获
			§ 外部变量
				□ 该变量是一个局部变量，该变量属于包含本地函数的成员
				□ 该变量在本地函数外部声明，并在本地函数内部使用
				□ 本地函数的形参不属于外部变量
				□ 将本地函数外部声明的变量作为实参传递不算做捕获
			§ 本地函数能够在封闭范围内明确分配捕获的变量
			§ 本地函数捕获了封闭范围中的外部变量时，本地函数将作为委托类型实现
				□ 本地函数会被转换成一个委托，委托的参数列表是由本地函数原本的参数列表和封装外部变量的值类型组成
					® 封装外部变量的值类型是以引用参数形式传递的
				□ 外部变量会被封装成一个值类型的成员，这个值类型是包含成员所在类的一个内部类
				□ 如果外部变量是循环变量，每捕获一个外部变量都会为其单独创建一个值类型来封装
			§ Lambda表达式捕获了封闭范围中的外部变量时
				□ 编译器会将Lambda表达式和其捕捉的外部变量封装成一个内部类
					® 外部变量成为这个类的实例字段
					® Lambda表达式会成为这个类的实例方法
					® Lambda表达式内捕获的外部变量此时在实例方法中替换成了对应的实例成员
				□ 包含成员原本的实现会改变为
					® 先声明并初始化一个内部类的实例
					® 将原本的外部变量替换成实例字段
					® 将原本的Lambda表达式替换成实例方法并赋值给委托
				□ 如果外部变量是循环变量
					® 循环变量和Lambda表达式会封装在一个内部类01中成为实例字段和实例方法
					® 如果同时捕获了非循环变量的外部变量，编译器会将该外部变量单独封装成一个内部类02
						◊ 同时会在内部类01中创建一个内部类02类型的实例字段
		○ 堆分配
			§ 如果本地函数永远不会转换为委托，并且本地函数捕获的变量都不会被其他转换为委托的Lambda表达式或本地函数捕获，则编译器可以避免堆分配
			§ 满足以上条件可以将本地函数声明为静态本地函数来确保避免在堆上对其进行分配
			§ Lambda表达式将始终在堆上进行分配
		○ yield关键字的用法
			§ 当在迭代器中时，将本地函数作为迭代器实现可以使用yield return语句生成一系列值
			§ Lambda表达式是不允许使用yield return语句
 */
namespace LearnCSharp.Basic
{
    internal class LearnLocalFunction
    {
		public static void StartLearnLocalFunction()
		{
			string title1 = "【学习本地函数】";
			const string title2 = "【学习本地函数】";

			//调用本地函数 只要方法内部定义了本地函数，可以在方法任意位置进行调用
			PrintString("哈哈哈哈哈");

			void PrintString(string aString)
			{
				Console.WriteLine("这个本地函数捕获了一个外部变量title1：{0}", title1);
				Console.WriteLine("这是一个本地函数输出：{0}",aString);
			}

			static void DoSomething()
			{
				Console.WriteLine("静态本地函数不能捕获外部局部变量，但是可以捕获外部局部常量title2：{0}",title2);
				Console.WriteLine("这是一个静态本地函数的输出");
			}

			Console.WriteLine();
			//调用本地函数
			DoSomething();
		}
    }
}
